<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MediaPipe Hands and Three.js Particle System</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600&family=Noto+Sans+SC:wght@700&display=swap");

      :root {
        --neon-cyan: #00ffff;
        --neon-blue: #00ffff;
        --neon-yellow: #ffff00;
        --neon-pink: #ff00ff;
        --neon-green: #00ff88;
        --hud-bg: rgba(0, 255, 255, 0.05);
        --hud-border: rgba(0, 255, 255, 0.25);
        --hud-glow: rgba(0, 255, 255, 0.45);
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #030303;
        font-family: "Orbitron", "Noto Sans SC", monospace;
        color: var(--neon-cyan);
      }

      canvas {
        display: block;
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        z-index: 2;
      }

      #input-video {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        opacity: 0.35;
        filter: saturate(1.2) contrast(1.15);
        transform: scaleX(-1);
        pointer-events: none;
        z-index: 1;
      }

      #hud {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 4;
      }

      .hud-item {
        position: fixed;
        padding: 10px 14px;
        font-size: 12px;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        background: var(--hud-bg);
        border: 1px solid var(--hud-border);
        box-shadow: 0 0 12px var(--hud-glow);
      }

      .top-left {
        top: 16px;
        left: 16px;
      }

      .top-right {
        top: 16px;
        right: 16px;
        text-align: right;
      }

      .bottom-left {
        bottom: 16px;
        left: 16px;
      }

      .bottom-right {
        bottom: 16px;
        right: 16px;
        text-align: right;
      }

      #fx {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 3;
      }

      #grid {
        position: absolute;
        inset: -40%;
        background-image: linear-gradient(rgba(0, 255, 255, 0.12) 1px, transparent 1px),
          linear-gradient(90deg, rgba(0, 255, 255, 0.12) 1px, transparent 1px);
        background-size: 60px 60px;
        opacity: 0.12;
        transform: perspective(900px) rotateX(68deg) translateY(80px);
        animation: gridDrift 18s linear infinite;
      }

      #scanlines {
        position: absolute;
        inset: 0;
        background-image: repeating-linear-gradient(
          to bottom,
          rgba(0, 255, 255, 0.06),
          rgba(0, 255, 255, 0.02) 1px,
          rgba(0, 0, 0, 0) 4px,
          rgba(0, 0, 0, 0) 6px
        );
        opacity: 0.16;
        mix-blend-mode: screen;
        animation: scanMove 6s linear infinite;
      }

      #vignette {
        position: absolute;
        inset: -10%;
        background: radial-gradient(circle at center, rgba(0, 0, 0, 0) 45%, rgba(0, 0, 0, 0.82) 78%);
      }

      @keyframes gridDrift {
        0% {
          transform: perspective(900px) rotateX(68deg) translateY(80px) translateX(0);
        }
        100% {
          transform: perspective(900px) rotateX(68deg) translateY(80px) translateX(-200px);
        }
      }

      @keyframes scanMove {
        0% {
          transform: translateY(0);
        }
        100% {
          transform: translateY(-40px);
        }
      }
    </style>
  </head>
  <body>
    <video id="input-video" autoplay playsinline muted></video>
    <div id="hud">
      <div class="hud-item top-left" id="hud-fps">FPS: --</div>
      <div class="hud-item top-right" id="hud-particles">Particles: 12000</div>
      <div class="hud-item bottom-left" id="hud-left">Left: --</div>
      <div class="hud-item bottom-right" id="hud-right">Right: --</div>
    </div>
    <div id="fx">
      <div id="grid"></div>
      <div id="scanlines"></div>
      <div id="vignette"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script>
      (() => {
        const config = {
          particleCount: 12000,
          particleSize: 2.4,
          returnFactor: 0.28,
          damping: 0.82,
          scatterRadius: 1.35,
          scatterStrength: 0.75,
          rippleRadius: 3.5,
          rippleFrequency: 6.5,
          rippleAmplitude: 0.7,
          bounceAmplitude: 0.45,
          ballRadius: 2.4,
          textDotSpacing: 4,
          textJitter: 0.05,
          leftSwipeThreshold: 12,
          leftSwipeRadius: 3.0,
          leftSwipeImpulse: 0.85,
          leftClosedMaxFingers: 0,
          leftRingSize: 140,
          leftRingOpacity: 0.85,
          leftRingPulse: 0.16,
          leftRingColor: 0xff2a2a,
          rightRippleThreshold: 10,
          rightRippleSpeed: 7.5,
          rightRippleWidth: 0.7,
          rightRippleStrength: 1.1,
          rightRippleDuration: 1.0,
          rightRippleCooldown: 0.25,
        };
        const mirrorVideo = true;
        const swapHandedness = mirrorVideo;
        const audio = {
          ctx: null,
          enabled: false,
          last: {
            leftSwitch: -Infinity,
            catch: -Infinity,
            nebula: -Infinity,
            ultimate: -Infinity,
            ripple: -Infinity,
            scatter: -Infinity,
          },
        };

        const enableAudio = () => {
          if (audio.enabled) return;
          const AudioCtx = window.AudioContext || window.webkitAudioContext;
          if (!AudioCtx) return;
          audio.ctx = new AudioCtx();
          audio.enabled = true;
          if (audio.ctx.state === "suspended") {
            audio.ctx.resume();
          }
        };

        const playTone = ({ freq, endFreq, duration = 0.12, type = "sine", gain = 0.05 }) => {
          if (!audio.enabled || !audio.ctx) return;
          const ctx = audio.ctx;
          const now = ctx.currentTime;
          const end = endFreq || Math.max(80, freq * 0.55);

          const master = ctx.createGain();
          master.gain.setValueAtTime(0.0001, now);
          master.gain.exponentialRampToValueAtTime(gain, now + 0.008);
          master.gain.exponentialRampToValueAtTime(0.0001, now + duration);

          const osc = ctx.createOscillator();
          osc.type = type === "triangle" ? "triangle" : "sawtooth";
          osc.frequency.setValueAtTime(freq, now);
          osc.frequency.exponentialRampToValueAtTime(end, now + duration);

          const osc2 = ctx.createOscillator();
          osc2.type = "square";
          osc2.frequency.setValueAtTime(freq * 1.35, now);
          osc2.frequency.exponentialRampToValueAtTime(end * 1.1, now + duration);

          const bufferSize = Math.max(1, Math.floor(ctx.sampleRate * duration));
          const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < bufferSize; i += 1) {
            const t = i / bufferSize;
            data[i] = (Math.random() * 2 - 1) * (1 - t) * 0.6;
          }
          const noise = ctx.createBufferSource();
          noise.buffer = buffer;

          const bandpass = ctx.createBiquadFilter();
          bandpass.type = "bandpass";
          bandpass.frequency.setValueAtTime(freq * 2.2, now);
          bandpass.Q.value = 1.3;

          const highpass = ctx.createBiquadFilter();
          highpass.type = "highpass";
          highpass.frequency.setValueAtTime(320, now);

          const noiseGain = ctx.createGain();
          noiseGain.gain.setValueAtTime(0.0001, now);
          noiseGain.gain.exponentialRampToValueAtTime(gain * 0.6, now + 0.01);
          noiseGain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

          osc.connect(master);
          osc2.connect(master);
          noise.connect(bandpass);
          bandpass.connect(highpass);
          highpass.connect(noiseGain);

          master.connect(ctx.destination);
          noiseGain.connect(ctx.destination);

          osc.start(now);
          osc2.start(now);
          noise.start(now);
          osc.stop(now + duration + 0.02);
          osc2.stop(now + duration + 0.02);
          noise.stop(now + duration + 0.02);
        };

        window.addEventListener("pointerdown", enableAudio, { once: true });
        window.addEventListener("keydown", enableAudio, { once: true });

        const textModes = {
          1: { text: "Hello World", color: 0x00ffff },
          2: { key: "gemini", text: "I am expermenting", color: 0xffff00 },
          3: { key: "useful", text: "Three.js", color: 0xff00ff },
          4: { key: "bye", text: "Mediapipe", color: 0x00ff88 },
        };

        const defaultColor = new THREE.Color(0x00ffff);
        const catchColor = new THREE.Color(0x00ffff);
        const orangeColor = new THREE.Color(0xff7a1a);
        const blackColor = new THREE.Color(0x050505);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 0, 32);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 0);
        document.body.appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        const basePositions = new Float32Array(config.particleCount * 3);
        const renderPositions = new Float32Array(config.particleCount * 3);
        const velocities = new Float32Array(config.particleCount * 3);
        const colors = new Float32Array(config.particleCount * 3);

        const glowTexture = (() => {
          const canvas = document.createElement("canvas");
          canvas.width = 64;
          canvas.height = 64;
          const ctx = canvas.getContext("2d");
          const gradient = ctx.createRadialGradient(32, 32, 2, 32, 32, 32);
          gradient.addColorStop(0, "rgba(255,255,255,1)");
          gradient.addColorStop(0.35, "rgba(255,255,255,0.45)");
          gradient.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, 64, 64);
          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          return texture;
        })();

        for (let i = 0; i < config.particleCount; i += 1) {
          const idx = i * 3;
          const radius = Math.random() * 2.2;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const x = radius * Math.sin(phi) * Math.cos(theta);
          const y = radius * Math.sin(phi) * Math.sin(theta);
          const z = radius * Math.cos(phi);
          basePositions[idx] = x;
          basePositions[idx + 1] = y;
          basePositions[idx + 2] = z;
          renderPositions[idx] = x;
          renderPositions[idx + 1] = y;
          renderPositions[idx + 2] = z;
          colors[idx] = defaultColor.r;
          colors[idx + 1] = defaultColor.g;
          colors[idx + 2] = defaultColor.b;
        }

        geometry.setAttribute("position", new THREE.BufferAttribute(renderPositions, 3));
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
          size: config.particleSize,
          map: glowTexture,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          sizeAttenuation: false,
          vertexColors: true,
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        const ringTexture = (() => {
          const canvas = document.createElement("canvas");
          canvas.width = 128;
          canvas.height = 128;
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.strokeStyle = "rgba(255, 40, 40, 0.95)";
          ctx.lineWidth = 6;
          ctx.shadowColor = "rgba(255, 40, 40, 0.85)";
          ctx.shadowBlur = 14;
          ctx.beginPath();
          ctx.arc(64, 64, 40, 0, Math.PI * 2);
          ctx.stroke();
          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          return texture;
        })();

        const leftRingGeometry = new THREE.BufferGeometry();
        leftRingGeometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array([0, 0, 0]), 3));
        const leftRingMaterial = new THREE.PointsMaterial({
          size: config.leftRingSize,
          map: ringTexture,
          transparent: true,
          opacity: config.leftRingOpacity,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          color: config.leftRingColor,
          sizeAttenuation: false,
        });
        const leftRing = new THREE.Points(leftRingGeometry, leftRingMaterial);
        leftRing.visible = false;
        scene.add(leftRing);

        const world = { width: 1, height: 1 };
        const textTargets = {};
        let nebulaTargets = new Float32Array(config.particleCount * 3);
        const catchOffsets = new Float32Array(config.particleCount * 3);
        const ballOffsets = new Float32Array(config.particleCount * 3);
        const ballColors = new Float32Array(config.particleCount * 3);

        const updateWorldSize = () => {
          const height = 2 * Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)) * camera.position.z;
          world.height = height;
          world.width = height * camera.aspect;
        };

        const buildTextTargets = (text) => {
          const canvas = document.createElement("canvas");
          canvas.width = 1024;
          canvas.height = 512;
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#000";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.font = 'bold 75px "Noto Sans SC", "Arial", sans-serif';
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = "#fff";
          ctx.fillText(text, canvas.width / 2, canvas.height / 2);

          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const pixels = imageData.data;
          const coords = [];
          const step = config.textDotSpacing;
          for (let y = 0; y < canvas.height; y += step) {
            for (let x = 0; x < canvas.width; x += step) {
              const idx = (y * canvas.width + x) * 4;
              const r = pixels[idx];
              const g = pixels[idx + 1];
              const b = pixels[idx + 2];
              if (r + g + b > 80) {
                coords.push([x + step * 0.5, y + step * 0.5]);
              }
            }
          }

          if (!coords.length) {
            coords.push([canvas.width / 2, canvas.height / 2]);
          }

          const targets = new Float32Array(config.particleCount * 3);
          const scale = 0.9;
          const width = world.width * scale;
          const height = world.height * scale;
          const count = coords.length;
          for (let i = 0; i < config.particleCount; i += 1) {
            const idx = i * 3;
            const pick = coords[(Math.random() * count) | 0];
            const jitterX = (Math.random() - 0.5) * config.textJitter;
            const jitterY = (Math.random() - 0.5) * config.textJitter;
            const x = (pick[0] / canvas.width - 0.5) * width + jitterX;
            const y = -(pick[1] / canvas.height - 0.5) * height + jitterY;
            targets[idx] = x;
            targets[idx + 1] = y;
            targets[idx + 2] = 0;
          }
          return targets;
        };

        const buildNebulaTargets = () => {
          const targets = new Float32Array(config.particleCount * 3);
          const spreadX = world.width * 1.25;
          const spreadY = world.height * 1.25;
          const spreadZ = 12;
          for (let i = 0; i < config.particleCount; i += 1) {
            const idx = i * 3;
            targets[idx] = (Math.random() - 0.5) * spreadX;
            targets[idx + 1] = (Math.random() - 0.5) * spreadY;
            targets[idx + 2] = (Math.random() - 0.5) * spreadZ;
          }
          return targets;
        };

        const buildCatchOffsets = () => {
          for (let i = 0; i < config.particleCount; i += 1) {
            const idx = i * 3;
            const radius = Math.random() * 1.1;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            catchOffsets[idx] = radius * Math.sin(phi) * Math.cos(theta);
            catchOffsets[idx + 1] = radius * Math.sin(phi) * Math.sin(theta);
            catchOffsets[idx + 2] = radius * Math.cos(phi);
          }
        };

        const buildBasketball = () => {
          const golden = Math.PI * (3 - Math.sqrt(5));
          for (let i = 0; i < config.particleCount; i += 1) {
            const idx = i * 3;
            const t = i / (config.particleCount - 1);
            const y = 1 - t * 2;
            const radius = Math.sqrt(1 - y * y);
            const theta = golden * i;
            const x = Math.cos(theta) * radius;
            const z = Math.sin(theta) * radius;
            ballOffsets[idx] = x * config.ballRadius;
            ballOffsets[idx + 1] = y * config.ballRadius;
            ballOffsets[idx + 2] = z * config.ballRadius;

            const seam =
              Math.abs(y) < 0.08 ||
              Math.abs(x) < 0.08 ||
              Math.abs(z) < 0.08 ||
              Math.abs(Math.sin(theta * 2) * y) < 0.06;

            const targetColor = seam ? blackColor : orangeColor;
            ballColors[idx] = targetColor.r;
            ballColors[idx + 1] = targetColor.g;
            ballColors[idx + 2] = targetColor.b;
          }
        };

        const rebuildTargets = () => {
          updateWorldSize();
          Object.values(textModes).forEach((mode) => {
            textTargets[mode.key] = buildTextTargets(mode.text);
          });
          nebulaTargets = buildNebulaTargets();
          buildCatchOffsets();
          buildBasketball();
        };

        rebuildTargets();

        const handState = {
          left: {
            detected: false,
            fingers: 0,
            open: false,
            target: new THREE.Vector3(),
            position: new THREE.Vector3(),
            speed: 0,
          },
          right: {
            detected: false,
            fingers: 0,
            open: false,
            target: new THREE.Vector3(),
            position: new THREE.Vector3(),
            speed: 0,
          },
        };

        const raycaster = new THREE.Raycaster();
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const ndc = new THREE.Vector2();
        const tempVec = new THREE.Vector3();

        const screenToWorld = (x, y) => {
          const mx = mirrorVideo ? 1 - x : x;
          ndc.set(mx * 2 - 1, -y * 2 + 1);
          raycaster.setFromCamera(ndc, camera);
          raycaster.ray.intersectPlane(plane, tempVec);
          return tempVec.clone();
        };

        const countExtendedFingers = (landmarks, handedness) => {
          let count = 0;
          const isRight = handedness === "Right";
          const thumbTip = landmarks[4];
          const thumbIp = landmarks[3];
          if (isRight ? thumbTip.x < thumbIp.x : thumbTip.x > thumbIp.x) {
            count += 1;
          }
          if (landmarks[8].y < landmarks[6].y) count += 1;
          if (landmarks[12].y < landmarks[10].y) count += 1;
          if (landmarks[16].y < landmarks[14].y) count += 1;
          if (landmarks[20].y < landmarks[18].y) count += 1;
          return count;
        };

        const updateHands = (results) => {
          handState.left.detected = false;
          handState.right.detected = false;
          if (!results.multiHandLandmarks || !results.multiHandLandmarks.length) {
            return;
          }
          results.multiHandLandmarks.forEach((landmarks, index) => {
            const handedness = results.multiHandedness[index].label;
            const fingerCount = countExtendedFingers(landmarks, handedness);
            const assignedHand = swapHandedness
              ? handedness === "Left"
                ? "Right"
                : "Left"
              : handedness;
            const palm =
              landmarks[0]
                ? {
                    x: (landmarks[0].x + landmarks[5].x + landmarks[9].x + landmarks[13].x + landmarks[17].x) / 5,
                    y: (landmarks[0].y + landmarks[5].y + landmarks[9].y + landmarks[13].y + landmarks[17].y) / 5,
                  }
                : { x: landmarks[0].x, y: landmarks[0].y };
            const palmWorld = screenToWorld(palm.x, palm.y);
            if (assignedHand === "Left") {
              handState.left.detected = true;
              handState.left.fingers = fingerCount;
              handState.left.open = fingerCount === 5;
              handState.left.target.copy(palmWorld);
            } else {
              const indexTip = landmarks[8];
              const indexWorld = screenToWorld(indexTip.x, indexTip.y);
              handState.right.detected = true;
              handState.right.fingers = fingerCount;
              handState.right.open = fingerCount === 5;
              handState.right.target.copy(indexWorld);
            }
          });
        };

        const initHands = () => {
          const video = document.getElementById("input-video");
          const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
          });
          hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.5,
          });
          hands.onResults(updateHands);

          const cameraFeed = new Camera(video, {
            onFrame: async () => {
              await hands.send({ image: video });
            },
            width: 1280,
            height: 720,
          });
          cameraFeed.start();
        };

        initHands();

        const hudFps = document.getElementById("hud-fps");
        const hudParticles = document.getElementById("hud-particles");
        const hudLeft = document.getElementById("hud-left");
        const hudRight = document.getElementById("hud-right");

        let activeTextKey = "hello";
        let uniformColor = defaultColor.clone();

        const updateLeftMode = () => {
          if (!handState.left.detected) {
            return;
          }
          const fingers = handState.left.fingers;
          if (fingers >= 1 && fingers <= 4) {
            const mode = textModes[fingers];
            if (mode && mode.key !== activeTextKey) {
              activeTextKey = mode.key;
            }
            uniformColor.setHex(mode.color);
          } else if (fingers === 5) {
            uniformColor.copy(catchColor);
          }
        };

        const updateHud = (fps) => {
          hudFps.textContent = `FPS: ${fps.toFixed(0)}`;
          hudParticles.textContent = `Particles: ${config.particleCount}`;
          if (handState.left.detected) {
            const leftStatus = handState.left.open
              ? "CATCH"
              : textModes[handState.left.fingers]
              ? textModes[handState.left.fingers].text
              : "TRACKING";
            hudLeft.textContent = `Left: ${leftStatus}`;
          } else {
            hudLeft.textContent = "Left: --";
          }
          if (handState.right.detected) {
            const rightStatus = handState.right.open ? "NEBULA" : "SCATTER";
            hudRight.textContent = `Right: ${rightStatus}`;
          } else {
            hudRight.textContent = "Right: --";
          }
        };

        let lastTime = performance.now();
        let fpsCounter = 0;
        let fpsTime = lastTime;
        const rightPrev = new THREE.Vector3();
        const leftPrev = new THREE.Vector3();
        const leftVel = new THREE.Vector3();
        let rightPrevValid = false;
        let leftPrevValid = false;
        let prevLeftFingers = 0;
        let prevLeftOpen = false;
        let prevRightOpen = false;
        let prevUltimate = false;
        let prevScatter = false;
        const rightRipple = {
          active: false,
          startTime: 0,
          center: new THREE.Vector3(),
          strength: 0,
          lastTrigger: -Infinity,
        };

        const animate = (time) => {
          requestAnimationFrame(animate);
          const now = time || performance.now();
          const dt = Math.min(0.033, (now - lastTime) / 1000);
          lastTime = now;

          updateLeftMode();

          if (handState.left.detected) {
            handState.left.position.lerp(handState.left.target, 0.3);
            if (!leftPrevValid) {
              leftPrev.copy(handState.left.position);
              leftPrevValid = true;
            }
            leftVel.copy(handState.left.position).sub(leftPrev);
            const leftSpeed = leftVel.length() / Math.max(dt, 0.001);
            handState.left.speed = leftSpeed;
            leftVel.multiplyScalar(1 / Math.max(dt, 0.001));
            leftPrev.copy(handState.left.position);
          }
          if (handState.right.detected) {
            handState.right.position.lerp(handState.right.target, 0.35);
            if (!rightPrevValid) {
              rightPrev.copy(handState.right.position);
              rightPrevValid = true;
            }
            handState.right.speed = handState.right.position.distanceTo(rightPrev) / Math.max(dt, 0.001);
            rightPrev.copy(handState.right.position);
          } else {
            handState.right.speed = 0;
            rightPrevValid = false;
          }
          if (!handState.left.detected) {
            handState.left.speed = 0;
            leftVel.set(0, 0, 0);
            leftPrevValid = false;
          }

          const leftOpen = handState.left.detected && handState.left.open;
          const rightOpen = handState.right.detected && handState.right.open;
          const ultimate = leftOpen && rightOpen;
          const nebula = rightOpen && !ultimate;
          const catchMode = leftOpen && !rightOpen;
          const scatter = handState.right.detected && !rightOpen && !ultimate;
          const textMode = !catchMode && !nebula && !ultimate;
          const leftClosed = handState.left.detected && handState.left.fingers <= config.leftClosedMaxFingers;

          const rippleBoost = Math.min(2.5, handState.right.speed * 0.6);
          const scatterRadiusSq = config.scatterRadius * config.scatterRadius;
          const leftSwipeRadiusSq = config.leftSwipeRadius * config.leftSwipeRadius;
          const uniformR = uniformColor.r;
          const uniformG = uniformColor.g;
          const uniformB = uniformColor.b;

          const timeSec = now * 0.001;
          if (leftClosed) {
            leftRing.visible = true;
            leftRing.position.copy(handState.left.position);
            const pulse = 1 + Math.sin(timeSec * 6) * config.leftRingPulse;
            leftRing.scale.setScalar(pulse);
            leftRing.material.opacity = config.leftRingOpacity * (0.85 + 0.15 * Math.sin(timeSec * 8));
          } else {
            leftRing.visible = false;
            leftRing.scale.setScalar(1);
          }
          const rotY = timeSec * 0.75;
          const rotX = timeSec * 0.55;
          const cosY = Math.cos(rotY);
          const sinY = Math.sin(rotY);
          const cosX = Math.cos(rotX);
          const sinX = Math.sin(rotX);

          const rightX = handState.right.position.x;
          const rightY = handState.right.position.y;
          const rightZ = handState.right.position.z;
          const leftX = handState.left.position.x;
          const leftY = handState.left.position.y;
          const leftZ = handState.left.position.z;
          const leftSpeed = handState.left.speed;
          const rightSpeed = handState.right.speed;
          let leftDirX = 0;
          let leftDirY = 0;
          let leftSwipePower = 0;
          if (handState.left.detected) {
            if (handState.left.fingers !== prevLeftFingers && handState.left.fingers >= 1 && handState.left.fingers <= 4) {
              if (timeSec - audio.last.leftSwitch > 0.12) {
                playTone({
                  freq: 520 + handState.left.fingers * 90,
                  endFreq: 420 + handState.left.fingers * 70,
                  duration: 0.12,
                  type: "square",
                  gain: 0.04,
                });
                audio.last.leftSwitch = timeSec;
              }
            }
            prevLeftFingers = handState.left.fingers;
          } else {
            prevLeftFingers = 0;
          }
          if (leftOpen && !prevLeftOpen && timeSec - audio.last.catch > 0.2) {
            playTone({ freq: 180, endFreq: 240, duration: 0.2, type: "sine", gain: 0.05 });
            audio.last.catch = timeSec;
          }
          if (rightOpen && !prevRightOpen && timeSec - audio.last.nebula > 0.25) {
            playTone({ freq: 260, endFreq: 680, duration: 0.4, type: "triangle", gain: 0.04 });
            audio.last.nebula = timeSec;
          }
          if (scatter && !prevScatter && timeSec - audio.last.scatter > 0.15) {
            playTone({ freq: 900, endFreq: 680, duration: 0.08, type: "square", gain: 0.025 });
            audio.last.scatter = timeSec;
          }
          if (ultimate && !prevUltimate && timeSec - audio.last.ultimate > 0.3) {
            playTone({ freq: 180, endFreq: 80, duration: 0.45, type: "sawtooth", gain: 0.06 });
            audio.last.ultimate = timeSec;
          }
          if (textMode && leftSpeed > config.leftSwipeThreshold) {
            const len = Math.hypot(leftVel.x, leftVel.y);
            if (len > 0.001) {
              leftDirX = leftVel.x / len;
              leftDirY = leftVel.y / len;
              leftSwipePower = Math.min(2, (leftSpeed - config.leftSwipeThreshold) / config.leftSwipeThreshold);
            }
          }
          if (textMode && scatter && rightSpeed > config.rightRippleThreshold) {
            if (timeSec - rightRipple.lastTrigger > config.rightRippleCooldown) {
              rightRipple.active = true;
              rightRipple.startTime = timeSec;
              rightRipple.center.set(rightX, rightY, rightZ);
              rightRipple.strength = Math.min(2, (rightSpeed - config.rightRippleThreshold) / config.rightRippleThreshold);
              rightRipple.lastTrigger = timeSec;
              if (timeSec - audio.last.ripple > 0.12) {
                playTone({ freq: 560, endFreq: 320, duration: 0.18, type: "sine", gain: 0.04 });
                audio.last.ripple = timeSec;
              }
            }
          }
          let rightRippleOn = false;
          let rightRippleRadius = 0;
          let rightRippleStrength = 0;
          let rightRippleX = 0;
          let rightRippleY = 0;
          if (textMode && rightRipple.active) {
            const age = timeSec - rightRipple.startTime;
            if (age > config.rightRippleDuration) {
              rightRipple.active = false;
            } else {
              rightRippleOn = true;
              rightRippleRadius = age * config.rightRippleSpeed;
              rightRippleStrength = rightRipple.strength * (1 - age / config.rightRippleDuration);
              rightRippleX = rightRipple.center.x;
              rightRippleY = rightRipple.center.y;
            }
          }

          const activeTargets = textTargets[activeTextKey] || textTargets.hello;

          for (let i = 0; i < config.particleCount; i += 1) {
            const idx = i * 3;
            let tx = 0;
            let ty = 0;
            let tz = 0;

            if (ultimate) {
              const ox = ballOffsets[idx];
              const oy = ballOffsets[idx + 1];
              const oz = ballOffsets[idx + 2];
              const rx = ox * cosY + oz * sinY;
              const rz = -ox * sinY + oz * cosY;
              const ry = oy * cosX - rz * sinX;
              const rzz = oy * sinX + rz * cosX;
              tx = leftX + rx;
              ty = leftY + ry;
              tz = leftZ + rzz;
            } else if (catchMode) {
              tx = leftX + catchOffsets[idx];
              ty = leftY + catchOffsets[idx + 1];
              tz = leftZ + catchOffsets[idx + 2];
            } else if (nebula) {
              tx = nebulaTargets[idx];
              ty = nebulaTargets[idx + 1];
              tz = nebulaTargets[idx + 2];
            } else {
              tx = activeTargets[idx];
              ty = activeTargets[idx + 1];
              tz = 0;
            }

            let vx = velocities[idx];
            let vy = velocities[idx + 1];
            let vz = velocities[idx + 2];
            let px = basePositions[idx];
            let py = basePositions[idx + 1];
            let pz = basePositions[idx + 2];

            px += (tx - px) * config.returnFactor;
            py += (ty - py) * config.returnFactor;
            pz += (tz - pz) * config.returnFactor;

            if (scatter) {
              const dx = px - rightX;
              const dy = py - rightY;
              const distSq = dx * dx + dy * dy;
              if (distSq < scatterRadiusSq) {
                const force = config.scatterStrength / (distSq + 0.001);
                vx += dx * force;
                vy += dy * force;
              }
              vz *= 0.5;
              pz += (0 - pz) * 0.08;
            }
            if (rightRippleOn) {
              const dx = px - rightRippleX;
              const dy = py - rightRippleY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist > 0.0001) {
                const diff = Math.abs(dist - rightRippleRadius);
                if (diff < config.rightRippleWidth) {
                  const wave = Math.cos((diff / config.rightRippleWidth) * (Math.PI / 2));
                  const impulse = config.rightRippleStrength * wave * rightRippleStrength;
                  vx += (dx / dist) * impulse;
                  vy += (dy / dist) * impulse;
                }
              }
            }
            if (leftSwipePower > 0) {
              const dx = px - leftX;
              const dy = py - leftY;
              const distSq = dx * dx + dy * dy;
              if (distSq < leftSwipeRadiusSq) {
                const dist = Math.sqrt(distSq);
                const falloff = 1 - dist / config.leftSwipeRadius;
                const impulse = config.leftSwipeImpulse * falloff * leftSwipePower;
                vx += leftDirX * impulse + dx * 0.04 * falloff;
                vy += leftDirY * impulse + dy * 0.04 * falloff;
              }
            }

            vx *= config.damping;
            vy *= config.damping;
            vz *= config.damping;

            px += vx;
            py += vy;
            pz += vz;

            basePositions[idx] = px;
            basePositions[idx + 1] = py;
            basePositions[idx + 2] = pz;
            velocities[idx] = vx;
            velocities[idx + 1] = vy;
            velocities[idx + 2] = vz;

            let ox = 0;
            let oy = 0;
            let oz = 0;
            if (nebula) {
              const dx = px - rightX;
              const dy = py - rightY;
              const dz = pz - rightZ;
              const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
              if (dist < config.rippleRadius) {
                oz = Math.sin(dist * config.rippleFrequency - timeSec * 5) * config.rippleAmplitude * rippleBoost;
              }
            } else if (ultimate) {
              oy = Math.sin(timeSec * 12 + i * 0.12) * config.bounceAmplitude;
            }

            renderPositions[idx] = px + ox;
            renderPositions[idx + 1] = py + oy;
            renderPositions[idx + 2] = pz + oz;

            const cr = colors[idx];
            const cg = colors[idx + 1];
            const cb = colors[idx + 2];
            let tr = uniformR;
            let tg = uniformG;
            let tb = uniformB;
            if (ultimate) {
              tr = ballColors[idx];
              tg = ballColors[idx + 1];
              tb = ballColors[idx + 2];
            }
            colors[idx] = cr + (tr - cr) * 0.12;
            colors[idx + 1] = cg + (tg - cg) * 0.12;
            colors[idx + 2] = cb + (tb - cb) * 0.12;
          }

          prevLeftOpen = leftOpen;
          prevRightOpen = rightOpen;
          prevUltimate = ultimate;
          prevScatter = scatter;

          geometry.attributes.position.needsUpdate = true;
          geometry.attributes.color.needsUpdate = true;

          renderer.render(scene, camera);

          fpsCounter += 1;
          if (now - fpsTime > 400) {
            const fps = (fpsCounter * 1000) / (now - fpsTime);
            fpsCounter = 0;
            fpsTime = now;
            updateHud(fps);
          }
        };

        requestAnimationFrame(animate);

        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          rebuildTargets();
        });
      })();
    </script>
  </body>
</html>
